;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Rewrite of binary in Lisp (as a sanity check)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun or (f g x y) (f x (g x y)))
(defun and (f g x y) (@C f y (g x y)))
(defun lstEq ()
  (@Y (lambda (r xs ys a b)
        (xs (ys a (lambda (u u) b))
            (lambda (x xt)
              (ys b (lambda (y yt)
                      (x (y @=) (r xt yt a b) b))))))))

(defun append () (@Y (lambda (r xs ys) (xs ys (lambda (x xt) (@: x (r xt ys)))))))
(defun pair (x y f) (f x y))
(defun Just (x f g) (g x))
(defun Nothing (f g) f)
(defun foldr () (@Y (lambda (r c n l) (l n (lambda (h t) (c h (r c n t)))))))
(defun foldl () (lambda (f a bs) (foldr (lambda (b g x) (g (f x b))) @I bs a)))
(defun foldlOne () (lambda (f bs) (bs @? (lambda (h t) (foldl f h t)))))
(defun elem (k xs) (lambda (a b) (foldr (lambda (x t) (x (k @=) a t)) b xs)))
(defun lstLookup (s) (foldr (lambda (h t) (h (lambda (k v) (lstEq s k (Just v) t)))) Nothing))

(defun R (s)   (lambda (a b c d) (a s)))
(defun V (v)   (lambda (a b c d) (b v)))
(defun A (x y) (lambda (a b c d) (c x y)))
(defun L (x y) (lambda (a b c d) (d x y)))

(defun pure (x inp) (Just (pair x inp)))
(defun bind (f m) (m @K (lambda (x) (x f))))
(defun ap (x y) (lambda (inp) (bind (lambda (a t) (bind (lambda (b u) (pure (a b) u)) (y t))) (x inp))))
(defun fmap (f x) (ap (pure f) x))
(defun alt (x y) (lambda (inp) ((x inp) (y inp) Just)))
(defun liftaa (f x y) (ap (fmap f x) y))
(defun many () (@Y (lambda (r p) (alt (liftaa @: p (r p)) (pure @K)))))
(defun some (p) (liftaa @: p (many p)))
(defun liftKI () (liftaa (@K @I)))
(defun liftK () (liftaa @K))
(defun between (x y p) (liftKI x (liftK p y)))
(defun sat (f inp) (inp @K (lambda (h t) (f h (pure h t) @K))))

(defun char (c) (sat (lambda (x) (x (c @=)))))
(defun com () (liftKI (char '-') (between (char '-') (char '\n') (many (sat (lambda (c) (@C (c ('\n' @=)))))))))
(defun sp () (many (alt (sat (lambda (c) (or (c(' '(@=))) (c('\n'(@=)))))) com)))
(defun spc (f) (liftK f sp))
(defun spch () (@B spc char))
(defun paren () (between (spch '(') (spch ')')))
(defun letter ()
  (sat (lambda (x)
         (or (and ('z' (x @L)) (x ('a' @L)))
             (and ('Z' (x @L)) (x ('A' @L)))))))

(defun digit () (sat (lambda (x) (and ('9' (x @L)) (x('0' @L))))))
(defun varId () (liftaa @: letter (many (alt letter digit))))
(defun syms () (some (sat (@C elem ":!#$%&*+./<=>?@\\^|-~"))))
(defun op () (alt (spc syms) (between (spch '`') (spch '`') (spc varId))))
(defun var () (alt (spc varId) (paren (spc syms))))
(defun anyOne () (fmap (@C @: @K) (spc (sat (@K @K)))))
(defun pre () (liftKI (char '@') anyOne))
(defun lam (r) (liftKI (spch '\\') (liftaa (@C (foldr L)) (some var) (liftKI (char '-') (liftKI (spch '>') r)))))
(defun listify () (fmap (foldr (lambda (h t) (A (A (R ":") h) t)) (R "K"))))
(defun escchar () (liftKI (char '\\') (alt (sat (lambda (c) (or (c('\"'(@=))) (or (c('\\'(@=))) (c('\''(@=))))))) (fmap (@K '\n') (char 'n')))))
(defun litOne (delim) (fmap (@B R (@B (@: '#') (@C @: @K))) (alt escchar (sat (lambda (c) (@C (delim(c(@=)))))))))
(defun litStr () (listify (between (char '\"') (spch '\"') (many (litOne '\"')))))
(defun litChar () (between (char '\'') (spch '\'') (litOne '\'')))
(defun lit () (alt litStr litChar))
(defun sepByOne (p sep) (liftaa (@:) p (many (liftKI sep p))))
(defun sepBy (p sep) (alt (sepByOne p sep) (pure @K)))
(defun sqLst (r) (listify (between (spch '[') (spch ']') (sepBy r (spch ',')))))
(defun atom (r) (alt (alt (alt (alt (alt (sqLst r) (paren r)) (lam r)) (fmap R pre)) (fmap V var)) lit))
(defun aexp (r) (fmap (foldlOne A) (some (atom r))))
(defun expr () (@Y (lambda (r) liftaa (foldl @T) (aexp r) (many (liftaa (lambda (f b a) (A (A (V f) a) b)) op (aexp r))))))
(defun def () (liftaa pair var (liftaa (@C (foldr L)) (many var) (liftKI (spch '=') expr))))
(defun program () (liftKI sp (some (liftK def (spch '\;')))))

(defun Ze   () (lambda (    a b c d e ) (a    )))
(defun Su   () (lambda (x   a b c d e ) (b x  )))
(defun Pass () (lambda (x   a b c d e ) (c x  )))
(defun La   () (lambda (x   a b c d e ) (d x  )))
(defun App  () (lambda (x y a b c d e ) (e x y)))

(defun debruijn ()
  (@Y (lambda (r n e)
        (e (lambda (s) (Pass (R s)))
           (lambda (v) (foldr (lambda (h m ) lstEq h v Ze (Su m)) (Pass (V v)) n))
           (lambda (x y) (App (r n x) (r n y)))
           (lambda (s t) (La (r (@: s n) t)))))))

(defun Defer () (lambda (a b c d) a))
(defun Closed () (lambda (t a b c d) (b t)))
(defun Need () (lambda (x a b c d) (c x)))
(defun Weak () (lambda (x a b c d) (d x)))

(defun ldef (r y)
  (y (Need (Closed (A (A (R "S") (R "I")) (R "I"))))
     (lambda (d) (Need (Closed (A (R "T") d))))
     (lambda (e) (Need (r (Closed (A (R "S") (R "I"))) e)))
     (lambda (e) (Need (r (Closed (R "T")) e)))))

(defun lclo (r d y)
  (y (Need (Closed d))
     (lambda (dd) (Closed (A d dd)))
     (lambda (e) (Need (r (Closed (A (R "B") d)) e)))
     (lambda (e) (Weak (r (Closed d) e)))))

(defun lnee ()
  (lambda (r e y)
    (y (Need (r (r (Closed (R "S")) e) (Closed (R "I"))))
       (lambda (d) (Need (r (Closed (A (R "R") d)) e)))
       (lambda (ee) (Need (r (r (Closed (R "S")) e) ee)))
       (lambda (ee) (Need (r (r (Closed (R "C")) e) ee))))))

(defun lwea ()
  (lambda (r e y)
    (y (Need e)
       (lambda (d) (Weak (r e (Closed d))))
       (lambda (ee) (Need (r (r (Closed (R "B")) e) ee)))
       (lambda (ee) (Weak (r e ee))))))

(defun babsa ()
  (@Y (lambda (r x y)
        (x (ldef r y)
           (lambda (d) (lclo r d y))
           (lambda (e) (lnee r e y))
           (lambda (e) (lwea r e y))))))

(defun babs ()
  (@Y (lambda (r t)
        (t Defer
           (@B Weak r)
           Closed
           (lambda (t)
             (r t
                (Closed (R "I"))
                (lambda (d) (Closed (A (R "K") d)))
                @I
                (babsa (Closed (R "K")))))
           (lambda (x y) (babsa (r x) (r y)))))))

(defun nolam (x) (babs (debruijn @K x) @? @I @? @?))
(defun primTab () (@: (pair "<=" "L") (@: (pair "==" "=") @K)))
(defun prim (s) (lstLookup s primTab s (append "``BT`T")))
(defun rank (ds v)
  (foldr (lambda (d t)
           (lstEq v (d @K)
                  (lambda (n) (@: '@' (@: n @K)))
                  (@B t (lambda (n)
                          (' ' ('!' (@-)) (n (@+)))))))
         (@K (prim v))
         ds
         ' '))
(defun show () (@Y (lambda (r ds t) (t @I (rank ds) (lambda (x y) (@:'`'(append (r ds x) (r ds y)))) @?))))
(defun dump ()
  (@Y (lambda (r tab ds) (ds "" (lambda (h t) (append (show tab (nolam (h (@K @I)))) (@: '\;' (r tab t))))))))

(defun main (s)
  (program s "?" (@B (lambda (ds) (dump ds ds)) (@T @K))))
